<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>SBOM Graph</title>
    <script src="https://unpkg.com/htmx.org@1.9.12"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: system-ui, Segoe UI, Roboto, Arial
        }

        #panel {
            margin-bottom: 1rem
        }

        #graph svg {
            border: 1px solid #ddd;
            border-radius: 8px
        }

        .node {
            cursor: grab
        }

        .node:active {
            cursor: grabbing
        }
    </style>
</head>
<body>
<h1>Dependency Graph</h1>

<div id="panel">
    <form id="filter" onsubmit="loadGraph(); return false;">
        <label>Root-Component:
            <input type="text" id="root" placeholder="z.B. demo-app">
        </label>
        <label>Depth:
            <input type="number" id="depth" value="3" min="1" max="8">
        </label>
        <label>Limit:
            <input type="number" id="limit" value="200" min="10" step="10">
        </label>
        <button type="submit">Laden</button>
        <button type="button" onclick="resetView()">Reset</button>
    </form>
</div>

<div id="graph"></div>

<script>
    function loadGraph(){
        const root = document.getElementById('root').value.trim();
        const depth = document.getElementById('depth').value;
        const limit = document.getElementById('limit').value;
        const url = new URL('/api/graph', window.location.origin);
        if (root) url.searchParams.set('root', root);
        url.searchParams.set('depth', depth);
        url.searchParams.set('limit', limit);

        fetch(url).then(r=>r.json()).then(data=>{
            // ---- Normalize: IDs als Strings, Links gegen Nodes prÃ¼fen
            const nodes = (data.nodes || []).map(n => ({ ...n, id: String(n.id) }));
            const nodeIds = new Set(nodes.map(n => n.id));

            const links = (data.links || [])
                .map(l => ({ source: String(l.source), target: String(l.target) }))
                .filter(l => nodeIds.has(l.source) && nodeIds.has(l.target));


            console.log(`RAW nodes=${(data.nodes||[]).length}, links=${(data.links||[]).length}`);
            console.log(`NORM nodes=${nodes.length}, links=${links.length}`);
            console.log("nodes[0..2]:", nodes.slice(0,3));
            console.log("links[0..2]:", links.slice(0,3));

            draw({ nodes, links });

        }).catch(err=>console.error(err));
    }


    function resetView() {
        document.getElementById('root').value = '';
        document.getElementById('depth').value = 3;
        document.getElementById('limit').value = 200;
        loadGraph();
    }

     function draw({nodes, links}){
        const w = 1000, h = 700;
        const container = d3.select("#graph");
        container.selectAll("*").remove();

        const svg = container.append("svg").attr("width", w).attr("height", h);

        // Wichtig: id(d) => d.id (String) MUSS zum nodes[].id passen
        const sim = d3.forceSimulation(nodes)
            .force("link", d3.forceLink(links).id(d => d.id).distance(80))
            .force("charge", d3.forceManyBody().strength(-200))
            .force("center", d3.forceCenter(w/2, h/2));



         const link = svg.append("g").attr("stroke-opacity", 0.6)
             .selectAll("line")
             .data(links)
             .enter()
             .append("line")
             .attr("stroke", "#999")          // ðŸ‘ˆ WICHTIG: ohne stroke keine Linie!
             .attr("stroke-width", 1);


         const circles = svg.append("g").selectAll("circle")
            .data(nodes).enter().append("circle")
            .attr("r", 6).attr("class","node")
            .call(drag(sim));

        svg.append("g").selectAll("title")
            .data(nodes).enter().append("title").text(d => d.label);

        const labels = svg.append("g").selectAll("text")
            .data(nodes).enter().append("text")
            .text(d=>d.label).attr("font-size", 10).attr("dx", 8).attr("dy", ".35em");

        sim.on("tick", ()=>{
            link.attr("x1", d=>d.source.x).attr("y1", d=>d.source.y)
                .attr("x2", d=>d.target.x).attr("y2", d=>d.target.y);
            circles.attr("cx", d=>d.x).attr("cy", d=>d.y);
            labels.attr("x", d=>d.x).attr("y", d=>d.y);
        });

        function drag(sim){
            function start(e,d){ if(!e.active) sim.alphaTarget(0.3).restart(); d.fx=d.x; d.fy=d.y; }
            function dragged(e,d){ d.fx=e.x; d.fy=e.y; }
            function end(e,d){ if(!e.active) sim.alphaTarget(0); d.fx=null; d.fy=null; }
            return d3.drag().on("start",start).on("drag",dragged).on("end",end);
        }
    }




    // initial
    loadGraph();
</script>
</body>
</html>
