<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>SBOM Graph</title>
    <script src="https://unpkg.com/htmx.org@1.9.12"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: system-ui, Segoe UI, Roboto, Arial
        }

        #panel {
            margin-bottom: 1rem
        }

        #graph svg {
            border: 1px solid #ddd;
            border-radius: 8px
        }

        .node {
            cursor: grab
        }

        .node:active {
            cursor: grabbing
        }
    </style>
</head>
<body>
<h1>Dependency Graph</h1>

<div id="panel">
    <form id="filter" onsubmit="loadGraph(); return false;">
        <label>Root-Component:
            <input type="text" id="root" placeholder="z.B. demo-app">
        </label>
        <label>Depth:
            <input type="number" id="depth" value="3" min="1" max="8">
        </label>
        <label>Limit:
            <input type="number" id="limit" value="200" min="10" step="10">
        </label>
        <button type="submit">Laden</button>
        <button type="button" onclick="resetView()">Reset</button>
    </form>
</div>

<div id="graph"></div>

<script>
    function loadGraph(){
        const root = document.getElementById('root').value.trim();
        const depth = document.getElementById('depth').value;
        const limit = document.getElementById('limit').value;
        const url = new URL('/api/graph', window.location.origin);
        if (root) url.searchParams.set('root', root);
        url.searchParams.set('depth', depth);
        url.searchParams.set('limit', limit);

        fetch(url).then(r=>r.json()).then(data=>{
            // ---- Normalize: IDs als Strings, Links gegen Nodes pr√ºfen
            const nodes = (data.nodes || []).map(n => ({ ...n, id: String(n.id) }));
            const nodeIds = new Set(nodes.map(n => n.id));

            const links = (data.links || [])
                .map(l => ({ source: String(l.source), target: String(l.target) }))
                .filter(l => nodeIds.has(l.source) && nodeIds.has(l.target));



            console.log(`RAW nodes=${(data.nodes||[]).length}, links=${(data.links||[]).length}`);
            console.log(`NORM nodes=${nodes.length}, links=${links.length}`);
            console.log("nodes[0..2]:", nodes.slice(0,3));
            console.log("links[0..2]:", links.slice(0,3));

            draw({ nodes, links });

        }).catch(err=>console.error(err));
    }


    function resetView() {
        document.getElementById('root').value = '';
        document.getElementById('depth').value = 3;
        document.getElementById('limit').value = 200;
        loadGraph();
    }

    function draw({ nodes, links }) {
        const width = 1000;
        const height = 700;

        // Container leeren
        const container = d3.select("#graph");
        container.selectAll("*").remove();

        // Neues SVG-Element
        const svg = container
            .append("svg")
            .attr("width", width)
            .attr("height", height)
            .style("border", "1px solid #ccc");

        // üß† Simulation (physikalisches Layout)
        const simulation = d3.forceSimulation(nodes)
            .force("link", d3.forceLink(links).id(d => d.id).distance(120))
            .force("charge", d3.forceManyBody().strength(-400))
            .force("center", d3.forceCenter(width / 2, height / 2));

        // üîó Kanten-Layer
        const link = svg.append("g")
            .attr("stroke", "#999")              // <- Linienfarbe
            .attr("stroke-opacity", 0.6)
            .selectAll("line")
            .data(links)
            .enter()
            .append("line")
            .attr("stroke-width", 1.5);

        // üîµ Knoten-Layer
        const color = d => d.type === "APPLICATION" ? "#7c3aed" : "#4682b4";
        const node = svg.append("g")
            .attr("stroke", "#fff")
            .attr("stroke-width", 1.5)
            .selectAll("circle")
            .data(nodes)
            .enter()
            .append("circle")
            .attr("r", 8)
            .attr("fill", color)
            .call(drag(simulation));

        // üè∑Ô∏è Labels
        const label = svg.append("g")
            .selectAll("text")
            .data(nodes)
            .enter()
            .append("text")
            .text(d => d.label)
            .attr("font-size", 10)
            .attr("dx", 12)
            .attr("dy", ".35em");

        // ü™Ñ Simulation l√§uft (bei jedem Tick Positionen aktualisieren)
        simulation.on("tick", () => {
            link
                .attr("x1", d => d.source.x)
                .attr("y1", d => d.source.y)
                .attr("x2", d => d.target.x)
                .attr("y2", d => d.target.y);

            node
                .attr("cx", d => d.x)
                .attr("cy", d => d.y);

            label
                .attr("x", d => d.x)
                .attr("y", d => d.y);
        });

        // üñ±Ô∏è Drag-Unterst√ºtzung
        function drag(simulation) {
            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }

            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }

            function dragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }

            return d3.drag()
                .on("start", dragstarted)
                .on("drag", dragged)
                .on("end", dragended);
        }
    }





    // initial
    loadGraph();
</script>
</body>
</html>
